apply plugin: 'java'
apply plugin: 'war'

buildscript {
    repositories {
        mavenCentral()
    }
}

repositories {
    mavenCentral()
    mavenLocal()
}

dependencies {
    compile 'org.apache.qpid:qpid-client:0.32'
    providedCompile 'org.jboss.spec.javax.ejb:jboss-ejb-api_3.2_spec:1.0.0.Final'
    providedCompile 'org.jboss.spec.javax.jms:jboss-jms-api_2.0_spec:1.0.0.Final'
    compile 'com.github.fernandospr:java-mpns:0.0.3'
}

artifacts {
    archives jar
}

jar {
    manifest {
        attributes("Dependencies":
                "deployment.qpid-client-0.32.jar, " +
                        "deployment.java-mpns-0.0.3.jar "
        )
    }
}


apply plugin: MyGradlePlugin

class MyGradlePlugin implements Plugin<Project> {

    File buildDir
    File dependencyWorkspace
    Project projectInstance
    String confName = 'compile'

    void apply(Project project) {
        projectInstance = project
        buildDir = project.buildDir
        dependencyWorkspace = new File(buildDir, 'dependency-workspace')


        project.task('modules') << {

            println "Project:" + project.name
            println "WildFly dependencies will be stored in '" + dependencyWorkspace + "'"
            boolean modulesDirCreated = dependencyWorkspace.mkdirs()
            println "dependencies directory created = ${modulesDirCreated}"
            println "dependencies directory exist = ${dependencyWorkspace.exists()}"

            Configuration conf = project.configurations[confName]
            println "    Configuration: ${conf.name} < ${conf.extendsFrom}"
            conf = conf.copy() // remove unnecessary dependencies from super configuration

            // http://gradle.org/docs/current/javadoc/org/gradle/api/artifacts/ResolvedConfiguration.html
            // http://gradle.org/docs/current/javadoc/org/gradle/api/artifacts/ResolvedDependency.html
            Set<ResolvedDependency> allDependencies = conf.resolvedConfiguration.firstLevelModuleDependencies

            processChildDependencies(allDependencies, 0, confName);
        }
    }

    void processChildDependencies(Set<ResolvedDependency> allDependencies, int level, String confName) {
        level++

        for (ResolvedDependency dep : allDependencies) {
            printDependency(dep, level)

            Set<ResolvedDependency> childrens = getChilderns(dep)

            // сначала спускаемся на нижние уровни рекурсии
            processChildDependencies(childrens, level, confName);

            // затем деплоим - сделано, чтобы порядок деплоя был таким: от конечных узлов дерева, не имеющих зависимостей, к родительским
            File changedJar = addChildDependenciesToManifest(dep)
            deployDeployment(changedJar)
        }

    }

    /**
     * Получает потомков dep, удаляет всех дублирующихся потомков от других конфигураций
     * @param dep какая-то зависимость
     * @return множество её потомков
     */
    Set<ResolvedDependency> getChilderns(ResolvedDependency dep) {
        Set<ResolvedDependency> childrens = new HashSet<ResolvedDependency>();
        dep.children.each {
            if (it.configuration == confName) {
                childrens.add(it)
            }
        }

        return childrens
    }

    void printDependency(ResolvedDependency dep, int level) {
        File jarSrc = getJarFromDependency(dep)
        String group = dep.module.id.group
        String name = dep.module.id.name
        String version = dep.module.id.version

        println " " + "*"*level + " id=${dep.module.id} file=${jarSrc}"
    }

    /**
     * Копирует .jar зависимости в папку dependency-workspace
     * Изменяет .jar: добавляет зависимостей-потомков в MANIFEST.MF
     * @param dep
     * @return
     */
    File addChildDependenciesToManifest(ResolvedDependency dep) {
        File jarSrc = getJarFromDependency(dep)
        String group = dep.module.id.group
        String name = dep.module.id.name
        String version = dep.module.id.version

        File jarDest = new File(dependencyWorkspace, jarSrc.name)
        GFileUtils.copyFile(jarSrc, jarDest)

        Set<ResolvedDependency> childrens = getChilderns(dep)

        if(childrens.size() > 0) {
            // Добавление в MANIFEST.MF зависимостей
            // https://github.com/jjzazuet/jgl/blob/master/jgl-demos/build.gradle
            projectInstance.ant.jar(destfile: jarDest, update: true) {
                delegate.manifest {
                    attribute(name: 'Dependencies', value: makeDependenciesString(childrens))
                }
            }
        }
        return jarDest
    }

    /**
     * Преобразует ResolvedDependency в File
     * @param dep
     * @return
     */
    File getJarFromDependency(ResolvedDependency dep) {
        return dep.moduleArtifacts.iterator()[0].file
    }

    String makeDependenciesString(Set<ResolvedDependency> childrens){
        StringBuilder sb = new StringBuilder()
        childrens.each {
            sb.append('deployment.')
            sb.append(getJarFromDependency(it).name)
            sb.append(' export')
            if(childrens.size() > 1) {
                sb.append(', ')
            }
        }

        return sb
    }

    /**
     * Один из вариантов деплоя
     * @param jarSrc
     */
    void deployDeployment(File jarSrc) {
        File wildflyDeploymentsFolder = new File("/home/nik/JavaInstruments/wildfly-8.2.0.Final/standalone/deployments/")
        File jarDest = new File(wildflyDeploymentsFolder, jarSrc.name)
        GFileUtils.copyFile(jarSrc, jarDest)
    }

}
